---
title: "Project3"
author: "Spencer Muncey and Chenchao Zang"
date: "October 15, 2015"
output: html_document
---
# Median Salary and population by zip code and number of fast food restaurants by zip code
There are two data sets for Project 3. These data sets can be used to determine the validity of the hypothesises. For example, the statement about if there are more fast food restaurants in higher income than in lower income can be determined by these two data sets.

## The data set 
The data first had to be extracted, transformed, and then loaded into the Oracle database. Here is the code that performs that ETL:

```
#Before running this R file make sure you set you working directory to where the CSV file located.

#For fastfood location csv file
file_path <- "fastfoodmaps_locations_2007.csv"

df <- read.csv(file_path, stringsAsFactors = FALSE)

# Replace "." (i.e., period) with "_" in the column names.
names(df) <- gsub("\\.+", "_", names(df))

str(df) # Uncomment this and  run just the lines to here to get column types to use for getting the list of measures.

measures <- c("Row_num", "Longnitude", "Lat")

# Make Zip codes all five digits
df$Zip <- gsub(df$Zip, pattern="-.*", replacement = "")
# remove leading zero on zip codes to match other data set
df$Zip <- gsub(df$Zip, pattern="^0", replacement = "")

# Get rid of special characters in each column.
# Google ASCII Table to understand the following:
for(n in names(df)) {
  df[n] <- data.frame(lapply(df[n], gsub, pattern="[^ -~]",replacement= ""))
}

dimensions <- setdiff(names(df), measures)

#dimensions
if( length(measures) > 1 || ! is.na(dimensions)) {
  for(d in dimensions) {
    # Get rid of " and ' in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern="[\"']",replacement= ""))
    # Change & to and in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern="&",replacement= " and "))
    # Change : to ; in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern=":",replacement= ";"))
  }
}


# Get rid of all characters in measures except for numbers, the - sign, and period.dimensions
if( length(measures) > 1 || ! is.na(measures)) {
  for(m in measures) {
    df[m] <- data.frame(lapply(df[m], gsub, pattern="[^--.0-9]",replacement= ""))
  }
}

write.csv(df, paste(gsub(".csv", "", file_path), ".reformatted.csv", sep=""), row.names=FALSE, na = "")

tableName <- gsub(" +", "_", gsub("[^A-z, 0-9, ]", "", gsub(".csv", "", file_path)))
sql <- paste("CREATE TABLE", tableName, "(\n-- Change table_name to the table name you want.\n")
if( length(measures) > 1 || ! is.na(dimensions)) {
  for(d in dimensions) {
    sql <- paste(sql, paste(d, "varchar2(4000),\n"))
  }
}
if( length(measures) > 1 || ! is.na(measures)) {
  for(m in measures) {
    if(m != tail(measures, n=1)) sql <- paste(sql, paste(m, "number(38,4),\n"))
    else sql <- paste(sql, paste(m, "number(38,4)\n"))
  }
}
sql <- paste(sql, ");")
cat(sql)

#For Median and ZIP csv file
#Before running this R file make sure you set you working directory to where the CSV file located.

file_path <- "MedianZIP-3-2.csv"

df <- read.csv(file_path, stringsAsFactors = FALSE)

# Replace "." (i.e., period) with "_" in the column names.
names(df) <- gsub("\\.+", "_", names(df))

str(df) # Uncomment this and  run just the lines to here to get column types to use for getting the list of measures.


measures <- c("Median", "Mean", "Pop")

# Get rid of special characters in each column.
# Google ASCII Table to understand the following:
for(n in names(df)) {
  df[n] <- data.frame(lapply(df[n], gsub, pattern="[^ -~]",replacement= ""))
}

dimensions <- setdiff(names(df), measures)
#dimensions
if( length(measures) > 1 || ! is.na(dimensions)) {
  for(d in dimensions) {
    # Get rid of " and ' in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern="[\"']",replacement= ""))
    # Change & to and in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern="&",replacement= " and "))
    # Change : to ; in dimensions.
    df[d] <- data.frame(lapply(df[d], gsub, pattern=":",replacement= ";"))
  }
}


# Get rid of all characters in measures except for numbers, the - sign, and period.dimensions
if( length(measures) > 1 || ! is.na(measures)) {
  for(m in measures) {
    df[m] <- data.frame(lapply(df[m], gsub, pattern="[^--.0-9]",replacement= ""))
  }
}

df$Median <- as.numeric(levels(df$Median))[df$Median]
df$Mean <- as.numeric(levels(df$Mean))[df$Mean]
df$Pop <- as.numeric(levels(df$Pop))[df$Pop]

write.csv(df, paste(gsub(".csv", "", file_path), ".reformatted.csv", sep=""), row.names=FALSE, na = "")

tableName <- gsub(" +", "_", gsub("[^A-z, 0-9, ]", "", gsub(".csv", "", file_path)))
sql <- paste("CREATE TABLE", tableName, "(\n-- Change table_name to the table name you want.\n")
if( length(measures) > 1 || ! is.na(dimensions)) {
  for(d in dimensions) {
    sql <- paste(sql, paste(d, "varchar2(4000),\n"))
  }
}
if( length(measures) > 1 || ! is.na(measures)) {
  for(m in measures) {
    if(m != tail(measures, n=1)) sql <- paste(sql, paste(m, "number(38,4),\n"))
    else sql <- paste(sql, paste(m, "number(38,4)\n"))
  }
}
sql <- paste(sql, ");")
cat(sql)
```
Here is the summary of the data sets:
require("jsonlite")
require("RCurl")

# Loads the data from Fast Food table into Fast Food dataframe
# Change the USER and PASS below to be your UTEid
fast_food <- data.frame(fromJSON(getURL(URLencode('129.152.144.84:5001/rest/native/?query="select * from FASTFOODMAPS_LOCATIONS_2007"'),httpheader=c(DB='jdbc:oracle:thin:@129.152.144.84:1521/PDBF15DV.usuniversi01134.oraclecloud.internal', USER='cs329e_sm44585', PASS='orcl_sm44585', MODE='native_mode', MODEL='model', returnDimensions = 'False', returnFor = 'JSON'), verbose = TRUE), ))

# Loads median, mean, and population data into Zip Code dataframe

zip_code <- data.frame(fromJSON(getURL(URLencode('129.152.144.84:5001/rest/native/?query="select * from MedianZIP32"'),httpheader=c(DB='jdbc:oracle:thin:@129.152.144.84:1521/PDBF15DV.usuniversi01134.oraclecloud.internal', USER='cs329e_sm44585', PASS='orcl_sm44585', MODE='native_mode', MODEL='model', returnDimensions = 'False', returnFor = 'JSON'), verbose = TRUE), ))

zip_code$MEAN <- as.numeric(levels(zip_code$Mean))[zip_code$Mean]
summary(fast_food)
summary(zip_code)
```


Here is the first ten rows of each data set:
```{r tidy=TRUE}
head(fast_food)
head(zip_code)
```

A detailed explanation of each column in the fastfood location data set:  

* RESTAURANT - First character of Fastfood Restaurant name
* ADDRESS - Fastfood restaurant's address
* CITY - Which city is the fastfood restaurant located in?
* STATE - Which state is the fastfood restaurant located in?
* ZIP - Zip code for that specific fastfood restaurant
* PHONE - Phone number for each fastfood restaurant
* ROW_NUM - 
* LONGNITUDE - 
* LAT - 

A detailed explanation of each column in the Median Zip code data set: 
* ZIP - 
* MEDIAN - 
* MEAN -
* POP -

## Session Info
This is how Rstudio is set up in order to execute the experiment and produce these results:
```{r}
sessionInfo()
```

### Plot 1: Average Number of Children per Wife's Education Level and Husband's Income

``` {r fig.width=12, fig.height=9}
source("../02 Data Wrangling/Project2_Plot1_df.r", echo = TRUE)
```

This plot was originally created to verify the hypothesis that there is an inverse relationship between the husband's income and average children as well as an inverse relationship between the wife's education level and the average number of children. In other words, the more educated a woman is, and the higher the husband's income, the less children they have on average.

However, after adding a box plot layer showing the mean and outlier income level of the husband for each education level of the wife, the data reveals an interesting phenomenon; the higher the wife's education level is, the higher the husband's income is. This suggests that the more educated a woman is, the higher her spouse's income is.

Data Wrangling R Workflow to produce the dataframe that powers this plot: 
```
Plot1_df <- df %>% group_by (EDUCATION, HUSBY) %>% summarise(mean_kids = mean(KIDSLT6 + KIDS618))
```
### Plot 2: Top and Bottom 10 Percent of Husband's Work Experience

``` {r fig.width = 9, fid.height = 9}
source("../02 Data Wrangling/Project2_Plot2_df.r", echo = TRUE)
```

This plot looks at how likely the husband is to have health insurance based on how much work experience he has and his income level.

This plot is interesting because it suggests that a husband's likelihood of having heath insurance is influenced more by his work experience than his income. The husbands in the top 10 percent of work experience are almost 6 times as likely to have health insurance than are the husbands who are in the bottom 10 percent of work experience.

Data Wrangling R Workflow to produce the dataframe that powers this plot: 
```
Plot2_df <- df %>% mutate(EXPERIENCE_PERCENT = cume_dist(EXPERIENCE)) %>% filter(EXPERIENCE_PERCENT  <= .1 | EXPERIENCE_PERCENT  >= .9)
```
### Plot 3: Influence of Number of Kids and No Health Insurance from Husband on Hours Worked by Wives

``` {r fig.width = 15, fid.height = 9}
source("../02 Data Wrangling/Project2_Plot3_df.r", echo = TRUE)
```

This plot is generated by a subset of the data where the husbands do not have health insurance through their employer. From that subset, this plot looks at how the number of kids affects the hours worked per week by the wife. 

Overall, the trend shown in the plot provides support for the hypothesis that even when a husband does not have health insurance, the wife will ultimately work less hours per week as she has more children.

Data Wrangling R Workflow to produce the dataframe that powers this plot: 
```
Plot3_df <- df %>% select(HHI, KIDSLT6, KIDS618, WHRSWK) %>% filter(HHI == "no") %>% mutate(TOTAL_KIDS = KIDSLT6 + KIDS618)
```
